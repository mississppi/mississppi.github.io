<!DOCTYPE html><html lang="ja" data-astro-cid-37fxchfa> <head><meta charset="UTF-8"><title>めも</title><style>body{margin:0;padding:20px;background-color:#fff;color:#000;font-family:MS PGothic,Osaka,sans-serif;font-size:14px}h1[data-astro-cid-37fxchfa],h2[data-astro-cid-37fxchfa],h3[data-astro-cid-37fxchfa]{font-weight:700;border-bottom:1px solid #000;padding-bottom:.25em}a[data-astro-cid-37fxchfa]{color:#00e;text-decoration:underline}a[data-astro-cid-37fxchfa]:visited{color:purple}hr[data-astro-cid-37fxchfa]{margin:2em 0;border:none;border-top:1px solid #aaa}ul[data-astro-cid-37fxchfa]{padding-left:1.5em}footer[data-astro-cid-37fxchfa]{margin-top:3em;font-size:12px;color:#666}.box[data-astro-cid-37fxchfa]{border:1px solid #000;padding:10px;background-color:#eee;margin-bottom:1em}.note[data-astro-cid-37fxchfa]{font-size:12px;color:#666}
</style></head> <body data-astro-cid-37fxchfa> <h1 data-astro-cid-37fxchfa>めも</h1> <main data-astro-cid-37fxchfa>  <h1 id="swiftui--coredata-めも">SwiftUI &#x26; CoreData めも</h1>
<p>SwiftUI と CoreData を使って開発していく中でのメモ。思い出しやすいように、よく使うパターン・お作法をまとめています。</p>
<hr>
<h2 id="-onappear-とは">💡 <code>onAppear</code> とは？</h2>
<p>View が画面に表示されたタイミングで何か処理を実行したいときに使う。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#79B8FF">Text</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Hello"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#79B8FF">onAppear</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        print</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"items"</span><span style="color:#E1E4E8">, items)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<hr>
<h2 id="-coredata-の使い方">🧠 CoreData の使い方</h2>
<h3 id="1-viewcontext-を環境にセット">1. <code>viewContext</code> を環境にセット</h3>
<p>CoreData を使うには <code>NSManagedObjectContext</code> を環境に渡しておく。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">environment</span><span style="color:#E1E4E8">(\.managedObjectContext, container.viewContext)</span></span></code></pre>
<h3 id="2-context-の保持">2. Context の保持</h3>
<p>ViewModel や View で使うために定義しておく：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> let</span><span style="color:#E1E4E8"> context: NSManagedObjectContext</span></span></code></pre>
<h3 id="3-データ取得nsfetchrequest">3. データ取得：<code>NSFetchRequest</code></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> request: NSFetchRequest&#x3C;Item> </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Item.</span><span style="color:#79B8FF">fetchRequest</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">request.sortDescriptors </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span></span>
<span class="line"><span style="color:#79B8FF">    NSSortDescriptor</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">keyPath</span><span style="color:#E1E4E8">: \Item.createdAt, </span><span style="color:#79B8FF">ascending</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">]</span></span></code></pre>
<h4 id="-nsfetchrequestitem-の構成">🔍 <code>NSFetchRequest&#x3C;Item></code> の構成</h4>

























<table><thead><tr><th>要素</th><th>内容</th></tr></thead><tbody><tr><td>Entity</td><td>どのエンティティを対象にするか → <code>Item</code></td></tr><tr><td>並び順</td><td><code>sortDescriptors</code></td></tr><tr><td>条件</td><td><code>predicate</code></td></tr><tr><td>件数制限</td><td><code>fetchLimit</code></td></tr></tbody></table>
<hr>
<h2 id="-viewmodel-のお作法">🧩 ViewModel のお作法</h2>
<p>MVVM の基本。データと UI の責務を分離する。</p>
<h3 id="-viewmodel-とは">✅ ViewModel とは？</h3>
<ul>
<li><strong>データとロジック</strong>の置き場</li>
<li>View はあくまで表示と操作のみを書く</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#E1E4E8">📦 ViewModel</span></span>
<span class="line"><span style="color:#F97583">├─</span><span style="color:#E1E4E8"> データ保持（tasks）</span></span>
<span class="line"><span style="color:#F97583">├─</span><span style="color:#E1E4E8"> CoreData操作（fetch, add, delete）</span></span>
<span class="line"><span style="color:#F97583">└─</span><span style="color:#E1E4E8"> 状態変化を </span><span style="color:#F97583">@Published</span><span style="color:#E1E4E8"> で通知</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">🖼️ View</span></span>
<span class="line"><span style="color:#F97583">├─</span><span style="color:#F97583"> @StateObject</span><span style="color:#E1E4E8"> で ViewModel を持つ</span></span>
<span class="line"><span style="color:#F97583">├─</span><span style="color:#E1E4E8"> 表示（List）</span></span>
<span class="line"><span style="color:#F97583">└─</span><span style="color:#E1E4E8"> UI操作（ボタン）</span><span style="color:#F97583">→</span><span style="color:#E1E4E8"> ViewModelの関数を呼ぶ</span></span></code></pre>
<hr>
<h2 id="️-enumの使い方">🗂️ <code>enum</code>の使い方</h2>
<h3 id="-ポイントまとめ">✅ ポイントまとめ</h3>

























<table><thead><tr><th>要素</th><th>内容</th></tr></thead><tbody><tr><td>enum 名</td><td>意味のある名詞 → <code>TaskIcon</code>（タスク用アイコン）</td></tr><tr><td>case</td><td>状態や種類を表す → <code>.delete</code>, <code>.done(Bool)</code></td></tr><tr><td>computed property</td><td>見た目の制御に使う → <code>systemName</code>, <code>color</code></td></tr><tr><td>switch 文</td><td>各状態で処理を分岐</td></tr></tbody></table>
<hr>
<h2 id="️-クロージャclosure">⚙️ クロージャ（Closure）</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> 42</span><span style="color:#E1E4E8"> }()</span></span></code></pre>
<h3 id="-覚え方">✅ 覚え方</h3>
<blockquote>
<p>「この関数、すぐ実行してその値くれ！」</p>
</blockquote>
<hr>
<h2 id="-nssortdescriptor-のおさらい">🌀 <code>NSSortDescriptor</code> のおさらい</h2>

























<table><thead><tr><th>項目</th><th>内容</th></tr></thead><tbody><tr><td>所属</td><td>Foundation（Objective-C 由来）</td></tr><tr><td>用途</td><td>CoreData、NSArray、NSFetchRequest など</td></tr><tr><td>Swift での役割</td><td>CoreData のクエリでの並び替えに必須</td></tr><tr><td>代替</td><td><code>sorted {}</code> を使うのも可（ただし非効率なことも）</td></tr></tbody></table>
<hr>
<h2 id="-sheetitem-の仕組み">📱 <code>.sheet(item:)</code> の仕組み</h2>
<ul>
<li><code>Identifiable</code> なオブジェクトを渡すことで、<code>sheet</code> を表示する形式。</li>
<li><code>nil → 非nil</code> になった瞬間に <code>sheet</code> が表示される。</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">sheet</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">item</span><span style="color:#E1E4E8">: $editingTask) { task </span><span style="color:#F97583">in</span></span>
<span class="line"><span style="color:#6A737D">    // 編集用のビューなど</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<blockquote>
<p>※ <code>Item</code> は <code>Identifiable</code> に準拠している（CoreData ではデフォルト）</p>
</blockquote>
<hr>
<h2 id="-state-ってなに">🧬 <code>@State</code> ってなに？</h2>
<blockquote>
<p>SwiftUI における「画面の状態」を保持するためのプロパティラッパー。</p>
</blockquote>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#F97583">@State</span><span style="color:#F97583"> private</span><span style="color:#F97583"> var</span><span style="color:#E1E4E8"> name: </span><span style="color:#79B8FF">String</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> ""</span></span></code></pre>
<ul>
<li>ユーザー操作で変わる値に使う</li>
<li>値が変わると画面が自動的に再描画される</li>
</ul>
<h3 id="-使用例">✅ 使用例</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="swift"><code><span class="line"><span style="color:#79B8FF">TextField</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"名前"</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">text</span><span style="color:#E1E4E8">: $name)</span></span>
<span class="line"><span style="color:#79B8FF">Text</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"こんにちは、</span><span style="color:#9ECBFF">\(name)</span><span style="color:#9ECBFF">さん！"</span><span style="color:#E1E4E8">)</span></span></code></pre>
<hr>
<h2 id="-状態のやりとりの図解">🔁 状態のやりとりの図解</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="text"><code><span class="line"><span>@State var name</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>$name（Binding）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>子Viewの @Binding var name</span></span></code></pre>
<p>→ 親 View から子 View に状態を渡すときの基本パターン。</p>
<hr>
<h2 id="initとは">init()とは</h2>
<p>View が作られるタイミングで最初に 1 回だけ呼ばれる特別な関数です。</p>
<h2 id="init-と-stateobject-のお作法">init と stateobject のお作法</h2>
<p>init で初期化するのがお作法</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>struct MyView: View {</span></span>
<span class="line"><span>    @StateObject var viewModel: MyViewModel</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    init() {</span></span>
<span class="line"><span>        _viewModel = StateObject(wrappedValue: MyViewModel())</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<h2 id="よく使うソートの書き方">よく使う「ソート」の書き方</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>return logs.sorted { ($0.date ?? .distantPast) > ($1.date ?? .distantPast) }</span></span></code></pre>
<p>✅ .distantPast ってなに？
Swift の Date 型が持ってる めっちゃ昔の日付（紀元前レベル）。</p>
<p>「ログの配列を、date の値（または昔の日）で比較して、新しい順に並べて返してる」</p>
<p>✅ 応用ポイント
sorted { $0.name ?? "" &#x3C; $1.name ?? "" } → 名前順にも使える</p>
<p>filter や map と組み合わせるとさらに便利</p>
<h2 id="navigationlink">NavigationLink</h2>
<p>次の画面に行くためのボタン</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>✅ 最小の例</span></span>
<span class="line"><span>swift</span></span>
<span class="line"><span>コピーする</span></span>
<span class="line"><span>編集する</span></span>
<span class="line"><span>NavigationLink("次へ") {</span></span>
<span class="line"><span>    Text("これは遷移先の画面です")</span></span>
<span class="line"><span>}</span></span></code></pre>
<h2 id="react-に例えながら値の更新通知について">react に例えながら値の更新通知について</h2>
<p>@Publised をつけると、値の更新時に通知されるようになる</p>
<p>@ObservedObject は親 View から渡されるこれを監視する</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>    @ObservedObject var habit: Habit</span></span></code></pre>
<h1 id="日付処理で覚えておくこと">日付処理で覚えておくこと</h1>






























<table><thead><tr><th>覚えるべき</th><th>内容</th><th>SwiftUI / iOS での具体例</th></tr></thead><tbody><tr><td>① 日付の生成</td><td>今日、月初などの Date を作る</td><td><code>Date()</code>, <code>Calendar.current.date(...)</code></td></tr><tr><td>② 日付の比較</td><td>同じ日？今日？未来？</td><td><code>Calendar.current.isDate(_:inSameDayAs:)</code></td></tr><tr><td>③ 日付の整形</td><td>表示用の文字列</td><td><code>DateFormatter().string(from:)</code></td></tr><tr><td>④ 範囲の取得</td><td>月の日数、週の範囲など</td><td><code>calendar.range(of: .day, in: .month, for:)</code></td></tr></tbody></table>
<p>意識しておくと今後楽になる</p>
<h2 id="dismiss-とは">dismiss とは</h2>
<p>SwiftUI で用意されている 環境変数の 1 つで、
シート（.sheet）やポップオーバーなどで表示された画面を 閉じる処理として使います。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Button("保存") {</span></span>
<span class="line"><span>    // データ保存処理...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    dismiss() // ← 表示されている画面（シート）を閉じる</span></span>
<span class="line"><span>}</span></span></code></pre>
<h1 id="-ミニマム版-persistencecontrollerswift">✅ ミニマム版 PersistenceController.swift</h1>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>struct PersistenceController {</span></span>
<span class="line"><span>    static let shared = PersistenceController()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let container: NSPersistentContainer</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    init(inMemory: Bool = false) {</span></span>
<span class="line"><span>        container = NSPersistentContainer(name: "MealLog") // ← .xcdatamodeld のファイル名と一致させること</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if inMemory {</span></span>
<span class="line"><span>            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: "/dev/null")</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        container.loadPersistentStores { _, error in</span></span>
<span class="line"><span>            if let error = error as NSError? {</span></span>
<span class="line"><span>                fatalError("Core Data store failed: \(error), \(error.userInfo)")</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        container.viewContext.automaticallyMergesChangesFromParent = true</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<h2 id="delete-rule">Delete Rule</h2>

























<table><thead><tr><th>Delete Rule</th><th>説明</th></tr></thead><tbody><tr><td><strong>Nullify</strong></td><td>リレーション先が削除されても、自分の参照だけ <code>nil</code> にする（安全でよく使う）</td></tr><tr><td><strong>Cascade</strong></td><td>リレーション先が削除されたら、自分自身も削除される（子が親に依存しているときに使う）</td></tr><tr><td><strong>Deny</strong></td><td>リレーション先が使われている限り削除を許さない（削除失敗させたい時）</td></tr><tr><td><strong>No Action</strong></td><td>何もしない（手動管理向け、普通は使わない）</td></tr></tbody></table>
<h1 id="app-ファイルからstateobject---environmentobject-で下に渡すってのはお作法">App ファイルから@StateObject -> .environmentObject で下に渡すってのはお作法</h1>
<p>ViewModel はこうやって渡すのがお作法。毎回 viewmodel が生成されるため。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Appファイル</span></span>
<span class="line"><span>@main</span></span>
<span class="line"><span>struct MyApp: App {</span></span>
<span class="line"><span>    @StateObject var viewModel = MyViewModel()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    var body: some Scene {</span></span>
<span class="line"><span>        WindowGroup {</span></span>
<span class="line"><span>            ContentView()</span></span>
<span class="line"><span>                .environmentObject(viewModel)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// 子ビュー</span></span>
<span class="line"><span>struct ContentView: View {</span></span>
<span class="line"><span>    @EnvironmentObject var viewModel: MyViewModel</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Appで定義</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>|- .environmentObjectに渡してあげる</span></span>
<span class="line"><span>|-- ContentView</span></span>
<span class="line"><span>|--- @EnvironmentObjectで受け取れる</span></span></code></pre>
<hr>
<h2 id="設計---エラーハンドリング">設計 - エラーハンドリング</h2>
<h3 id="1-失敗しそうな操作は適切に伝える">1. 失敗しそうな操作は「適切に伝える」</h3>
<p>意識: エラーが発生する可能性があるなら、黙殺しない。必ず呼出元にその事実を伝える。
実装: エラー/失敗の可能性を型で明示することもある</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Optional</span></span>
<span class="line"><span>Result&#x3C;Success, Failuer></span></span>
<span class="line"><span>Result&#x3C;[None], DataServiceError></span></span></code></pre>
<h3 id="2-エラーは最も適切に処理できる場所でキャッチをする">2. エラーは「最も適切に処理できる場所」でキャッチをする</h3>
<p>意識: エラー発生場所で全て処理しない。最も有意義に解釈しできて回復もでき、ユーザへ情報を提供できるレイヤーまで伝搬させることもある
MVVM: 低レベル層はカスタムエラーを変換、中間層はカスタムエラーをキャッチ。UI 層は通知する。</p>
<h3 id="3-エラーの種類に応じた適切な対応をする">3. エラーの種類に応じた適切な対応をする</h3>
<p>意識: ユーザにどう伝えるか、アプリとしてどう回復継続するか
やること: 回復可能ならユーザの再試行を促す、デフォルト値を使う。不能なら安全に終了を促す。ログを出す。</p>
<h3 id="4-エラーはなるべく早く発見なるべく早く伝える">4. エラーはなるべく早く発見、なるべく早く伝える</h3>
<p>意識: 問題が起きたらすぐにそれを意識し、コード上の適切な場所でエラーとして表現する
やること: 早期リターンを徹底する</p>
<hr>
<p>##　よく使うスタイルについて</p>
<h3 id=""></h3>






























<table><thead><tr><th>Delete Rule</th><th>説明</th><th>使い方</th></tr></thead><tbody><tr><td><strong>resizable</strong></td><td>View のサイズ調整。適用しない場合、Image は元の画像サイズで表示され、frame モディファイアなどでサイズを変更しようとしても無視されます。</td><td>　 Image(”…”) .resizable()のように使います。</td></tr><tr><td><strong>Cascade</strong></td><td>View のアスペクト比を維持しつつ、サイズを調整する。</td><td>Image(”…”) .resizable() .scaledToFit()のように使います。</td></tr><tr><td><strong>Image のサイズ調整</strong></td><td>Image のサイズを調整する場合、resizable()を最初に適用し、その後に scaledToFit()や scaledToFill()、そして frame モディファイアを連鎖させるのが一般的なパターンです。</td><td>resizable()はサイズ調整の「許可」を与え、scaledToFit()はサイズ調整の「方法」を指示します。両者を組み合わせることで、アイコンや画像が意図したサイズで表示されます。</td></tr><tr><td><strong>No Action</strong></td><td>何もしない（手動管理向け、普通は使わない）</td><td></td></tr></tbody></table>
<hr>
<p>#　 LLM の整理</p>
<h3 id="-1"></h3>
<h3 id="ニューラルネットワーク">ニューラルネットワーク</h3>
<p>ニューロンを模倣した計算モデル
情報を層で少しずつ変換して処理する。という特徴
段階的に抽象度を上げながら理解を深めていく。<br>
LLM は何百層にもなっていて、複雑なパターンが読み取れる</p>
<h3 id="llm-の進化">LLM の進化</h3>
<p>2 つの強みで進化してきた。</p>
<h4 id="1-事前学習-pre-training">1. 事前学習　 Pre-training</h4>
<p>一般的なルールやパターン。百科事典的な</p>
<h4 id="2ファインチューニング">2.　ファインチューニング</h4>
<p>特定の目的に合わせて微調整する。</p>
<h4 id="llm-の学習について">LLM の学習について</h4>
<p>自己教師あり学習という方法。ラベルがない。テキストとのものでモデル訓練している。
また、このモデルをスケールさせればタスク性能も向上するという仮説で GPT-3 くらいまではきていた。</p>
<h2 id="自然言語処理について">自然言語処理について</h2>
<p>言葉をコンピュータに理解させる技術のことを指す。これは昔は専用のモデルが必要とされていた。
近年はそうでもない。汎用 LLM とも言われてきている。</p>
<h3 id="汎用-llm-について">汎用 LLM について</h3>
<p>得意なこと</p>
<p>・テキスト生成
・質問応答
・翻訳・ようやく
・コード生成</p>
<h2 id="機械学習との違い">機械学習との違い</h2>
<p>そもそも、「データからルールを自動で学習する」技術。ただデメリット
・特定のタスクに対して特定のモデル。
・学習には大量ラベル月データが必要
・新規タスクは、ゼロからモデル構築</p>
<p>LLM は全く異なるスタンスとなる。
・事前学習で得ている言語の一般知識
・トランファーラーニングによるタスク適応
・スケーラブルなモデル</p>
<h3 id="トランスフォーマ">トランスフォーマ</h3>
<p>LLM は、従来のモデルである RNN, CNN とは別のアテンション概念を使っている。
Tranformer, Transfor ラーニングで構築。これが根本から違うらし。</p>
<hr>
<h1 id="トランスフォーマ-1">トランスフォーマ</h1>
<p>RNN, LSTM だと長文が文脈保持が難しかったが、並列処理が可能で、単語間の関係も効率的に捉えることができる用になった。</p>
<h2 id="主要構造">主要構造</h2>
<p>エンコーダ(BERT が特化)、でこーだ(GPT)、T5(両方)</p>
<p>##　最大の特徴
self-attention-mechanism と呼ばれる、各単語の関連を計算する仕組み。
とにかくこれが文脈を深く理解し、適切なテキスト生成のために欠かせない仕組みとなっている。
具体的には、入力テキストの各単語が、文中の他の単語とどの程度関連してるか、数値的に計算する。重みを調整することができる。</p>
<h2 id="attention-の仕組み">Attention の仕組み</h2>
<p>スケールドットプロダクトアテンションと呼ばれる処理について設名する。</p>
<p>Query: 注目する単語
Key: 他単語の情報、比較の対象
Value: 関連性に基づいて出力される意味情報</p>
<p>ここからが本題。処理の手順</p>
<ol>
<li>クエリとキーの内積計算</li>
<li>ソフトマックス関数を使う。スコアを確率分布に変換</li>
<li>vaalue を重み付で加算。ベクトルを出力</li>
</ol>
<p>さらにマルチヘッドアテンションを使い強化している。
これは以下となる</p>
<ol>
<li>
<p>複数の自己注意メカニズムをヘッドを並列に実行
それぞれのクエリキーバリュー行列を用いる</p>
</li>
<li>
<p>それぞれのヘッドを結合、結合ベクトルを生成</p>
</li>
<li>
<p>最終的に、統合ベクトルを活用して文章を処理</p>
</li>
</ol>
<p>これで単語間の関係を複数の視点から同時に分析できる。高度なことができる。</p>
<h2 id="時代を築いたモデル">時代を築いたモデル</h2>





















<table><thead><tr><th>モデル名</th><th>説明</th></tr></thead><tbody><tr><td>BERT Google(2018)</td><td>初のトランスフォーマモデル。Encoder 型。Google 検索</td></tr><tr><td>GPT(OpenAI)</td><td>自己回帰型モデル。文の前方(左側)の文脈のみで次の単語を予測する。</td></tr><tr><td>T5 Google(2020)</td><td>Encoder,Decoder トランスフォーマ。テキスト to テキスト</td></tr></tbody></table>
<h2 id="現在の-llm-たち特徴">現在の LLM たち。特徴</h2>

















































<table><thead><tr><th>モデル名</th><th>説明</th></tr></thead><tbody><tr><td>Claude4 ファミリー</td><td>—</td></tr><tr><td>Claude4 Opus4 (Anthropic)</td><td>最大 20 万トークン以上の文脈保持、ツール連携、メモリ保持などもできる。用途はコード生成、複数分析のドキュメント処理</td></tr><tr><td>Claude4 Sonnet4</td><td>3.7 の後継。　バランス型。対話型エージェント。FAQ システム。日常業務の要約・分析</td></tr><tr><td>Gemini 2.5 ファミリー</td><td>---</td></tr><tr><td>Gemini2.Pro</td><td>100 マントークン以上の長文文脈処理に対応。数学、化学、コーディングで良き</td></tr><tr><td>Gemini2.5Flash</td><td>ノーマル用途に最適化された。日常的なユースケース</td></tr><tr><td>Llama ファミリー</td><td>---</td></tr><tr><td>Llama4 　 Scout</td><td>Moe 構造。コード生成も。専門レポートのようやく、開発支援 AI</td></tr><tr><td>Mistral/Mixtral(Mistral.ai)</td><td>OSS,MOE 構造。</td></tr><tr><td>CommandR+(Cohere)</td><td>RAG（検索拡張生成)に最適化されたモデル。社内ナレッジ検索、法務・契約レビュー支援</td></tr></tbody></table>
<h1 id="llm-のトレーニング方法">LLM のトレーニング方法</h1>
<p>どうやって言葉を理解するのか。
インプット: ニュース、書籍、web、会話、コードなど.　　
データセットとも言われる。</p>
<p>ただしこれらはクリーンな状態のデータにする必要がある
・スパムの除去
・html タグの除去
・絵文字
・重複データの削除
・文法ミス、誤字修正</p>
<p>揺れも問題になる。Normalization する。</p>
<p>tokenization と呼ばれるが、単語分割する。
・スペースごとに区切る
・形態素解析。品詞単位
・サブワード。よく出現する部分単位で分割</p>
<p>ただし、バイアスかかるため偏ったデータは好ましくない</p>
<h2 id="トレーニングステップの概要">トレーニングステップの概要</h2>
<p>まず膨大なデータと計算資源がいる。具体的には次のステップ</p>
<ol>
<li>
<p>初期化-モデルのパラメータをランダムに設定する<br>
ランダム初期化、Xaview/Glorot 初期化、He 初期化などがある</p>
</li>
<li>
<p>フォワードプロ派ゲーション-入寮を処理し、予測結果を生成</p>
</li>
<li>
<p>ロス計算-予測結果と正解データの誤差を測定する</p>
</li>
<li>
<p>バックプロ派ゲーション-誤差を下にパラメータ修正する</p>
</li>
<li>
<p>エポックの繰り返し-上記プロセスを何百万回も繰り返す。モデル改善</p>
</li>
</ol>  </main> <hr data-astro-cid-37fxchfa> <footer data-astro-cid-37fxchfa>
&copy; 2025 techcampesinos
<br data-astro-cid-37fxchfa> <span class="note" data-astro-cid-37fxchfa>This page is best viewed with Netscape Navigator 4.7</span> </footer> </body></html>